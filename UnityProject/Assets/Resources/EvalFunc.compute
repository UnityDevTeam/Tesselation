#pragma kernel ComputeDensity
//#pragma kernel CSEvalAtom
RWTexture3D<float4> Result;
StructuredBuffer<float4> molPositions;
float3 dx;
float3 minBox;
int atomCount;

static float SR=1.3;
float eval(in float3 p) 
{
	float S=0;
	[loop]
    for (int i=0;i<atomCount;i++)
	{
		float3 apt = molPositions[i].xyz;
		float radius = molPositions[i].w;
		float3 YD = apt - p;
		float r = dot(YD,YD);
		float b = SR*SR;
		float a = -log(0.5f/b)/(radius*radius);
		float gauss_f = b*exp(-(r*a));
		S+=gauss_f;
		//lfadksadslkj
		//nml = nml + 2.0*b*a*gauss_f*YD;
	}  
	return S;
}

[numthreads(8,8,8)]
void ComputeDensity(uint3 id : SV_DispatchThreadID)
{
	float3 vol_pos = float3(id.x,id.y,id.z);
	float3 p = minBox + vol_pos*dx;
	float fval = eval(p);
	//fval = 0.1 + vol_pos.x/32.0;
	float4 c;
	c.r = c.g = c.b = c.w = fval;
	Result[id] = c;
}
/*
int3 getVoxel(in float3 p)
{
	int3 id = (p-minBox)/dx;
	return id;
}

[numthreads(1000,1,1)]
void CSEvalAtom(uint3 id : SV_DispatchThreadID)
{
	uint atomidx = id.x;
	float4 apt = molPositions[i];
	float radius = apt.w;
	float3 vol_pos = float3(id.x,id.y,id.z);
	float3 p = minBox + vol_pos*dx;
	float fval = eval(p);
	//fval = 0.1 + vol_pos.x/32.0;
	float4 c;
	c.r = c.g = c.b = c.w = fval;
	Result[id] = c;
}
*/
